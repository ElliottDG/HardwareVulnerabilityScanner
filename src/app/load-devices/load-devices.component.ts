import { Component, Type, ViewChild } from '@angular/core';
import { WebHidService } from '../services/web-hid.service';
import { MatTable } from '@angular/material/table';
import { Router } from '@angular/router';
import { BackendService } from '../services/backend.service';
import { from, switchMap } from 'rxjs';

@Component({
  selector: 'app-load-devices',
  templateUrl: './load-devices.component.html',
  styleUrls: ['./load-devices.component.scss'],
})
export class LoadDevicesComponent {
  // stringSimilarity = require('string-similarity');
  dataSource: any[] = [];
  displayedColumns: string[] = [
    'deviceNumber',
    'deviceName',
    'vendorId',
    'productId',
  ];
  deviceNumber: number = 1;
  addedDevices: number[] = [];
  cveDBData: any[] = [];
  NVDLINK = 'https://nvd.nist.gov/vuln/detail/';
  WARNINGMESSAGE =
    'Devices that break validation or do not exist in the table of USB vendors will be emitted.';

  @ViewChild(MatTable) table!: MatTable<any>;

  constructor(
    private webHidService: WebHidService,
    private router: Router,
    private backend: BackendService
  ) {}

  intTo4Hex(num: number): string {
    let retNum: string = '';
    return (retNum = num.toString(16).padStart(4, '0'));
  }

  loadDevices(): void {
    this.webHidService.requestDevice().then((devices) => {
      if (this.addedDevices.includes(devices.productId)) {
      } else {
        if (devices) {
          for (let i = 0; i < devices.length; i++) {
            const dataItem = {
              deviceNumber: this.deviceNumber,
              deviceName: devices[i].productName,
              vendorId: devices[i].vendorId,
              productId: devices[i].productId,
            };
            // Add the dataItem to the dataSource array
            this.addedDevices.push(devices[i].productId);
            this.dataSource.push(dataItem);
            this.deviceNumber++;
            this.table.renderRows();
          }
        }
      }
    });
  }

  clearDevices(): void {
    this.dataSource = [];
    this.deviceNumber = 1;
    this.table.renderRows();
    window.location.reload(); // only way to reset webhid :/
  }

  async scanData(): Promise<void> {
    let vendorsNum: string[] = this.dataSource.map((item) => item.vendorId);
    let vendorsJSON = { ids: vendorsNum };
    let vendors: any;
    let vulnerabilities: any;

    this.backend
      .post('USB/vendors', vendorsJSON, {
        headers: { 'Content-Type': 'application/json' },
      })
      .pipe(
        switchMap((data) => {
          vendors = data;
          let allProducts: any = { devices: [] };
          let dataItem = {};
          for (let i = 0; i < this.dataSource.length; i++) {
            const id = this.intTo4Hex(this.dataSource[i].vendorId);
            dataItem = {
              vendor: vendors.find((item: any) => item.vendorids === id)
                ?.vendornames,
              product: this.dataSource[i].deviceName,
            };
            allProducts.devices.push(dataItem);
          }
          // allProducts.devices.push({
          //   vendor: 'HP, Inc',
          //   product: 'Officejet Pro 8500',
          // });
          return this.backend.post('CVE/Vulnerabilities', allProducts, {
            headers: { 'Content-Type': 'application/json' },
          });
        })
      )
      .subscribe({
        next: (data) => {
          vulnerabilities = data;
          if (vulnerabilities?.length < 1 || vulnerabilities === null) {
          } else {
            for (let i = 0; i < vulnerabilities.length; i++) {
              let tabledata = {
                finding: vulnerabilities[i].cveData.id,
                device: vulnerabilities[i].product,
                severity: parseFloat(vulnerabilities[i].cveData.cvss.v2),
                cveLink: this.NVDLINK + vulnerabilities[i].cveData.id,
                cwe: vulnerabilities[i].cveData.cwes[0],
                status: 'Vulnerable',
              };
              this.cveDBData.push(tabledata);
            }
          }
          this.dataSource = [];
          this.deviceNumber = 1;
          this.router.navigate(['/ScanResults'], {
            state: { data: this.cveDBData },
          });
        },
        error: (error) => {
          console.log(error);
        },
      });
  }

  toScanResults(): void {
    this.scanData();
  }
}
